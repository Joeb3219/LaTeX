\documentclass[answers]{exam}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\newcommand{\oneline}{\fillwithlines{0.25in}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\newcommand{\duedate}{December 7, 2017}
\date{\duedate}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\def\therefore{\boldsymbol{\text{ }
\leavevmode
\lower0.4ex\hbox{$\cdot$}
\kern-.5em\raise0.7ex\hbox{$\cdot$}
\kern-0.55em\lower0.4ex\hbox{$\cdot$}
\thinspace\text{ }}}

\pagestyle{headandfoot}
\headrule
\header{CS111 Final Review}{Joseph A. Boyle}{\duedate}

\begin{document}

\pagebreak

\begin{questions}

    \question Consider an algorithm which sorts an array of numbers. What is the Big-O running time of each of (i) Insertion Sort, (ii) Selection Sort, and (iii) Merge Sort in the following scenarios:
    	\begin{parts}
    		\part The array is sorted in ascending order.
    		\part The array is sorted, but backwards (ie: descending order).
    	\end{parts}
    	
    \question Based on the previous question, consider which sorting algorithm you would use in part ($a$), and which you would use in part ($b$). Why?
    
    \question If you knew nothing about the dataset (ie: you don't know if the array is mostly sorted or if it's totally unsorted), would you choose to write a Selection Sort or an Insertion Sort? Why? 
    
    \question Write a program that, given an array of integers, \textit{ints}, computes:
    
    $$\sum_{i=0}^{n}{(ints[i])^2 - ints[i] + 2}$$ 

	If $n$ is the number of elements in \textit{ints}, what is the Big-O running time of your algorithm?    
    
	\question Write a program that, given a number, $n$, creates an array where each index, $i$, holds the $i^{th}$ digit of $n$. IE, given $12345$, we would create the array: \{1,2,3,4,5\}    
	
	\question Write a program that, given two integer arrays, $a$ and $b$, creates an array $c$ which is $a$ concatenated with $b$. IE, $a =  \{1,2,3\}$, and $b = \{4,5,6\}$, $\therefore c =  \{1,2,3,4,5,6\}$. What's the Big-O running time of your algorithm?
	
	\question Write a program that, given an array of Strings, does two passes of printing all of the strings (IE: if there are six strings, it will print all six strings once, and then print them all again). What is the Big-O running time of your algorithm?	
	
	\question When is it advantageous (read: \textit{better}) to use Binary Search instead of Sequential Search? 
		\begin{parts}
			\part If you only need to do one search and your data is unsorted, is it better to use Binary or Sequential Search?
			\part If you only need to do one search and your data is sorted, is it better to use Binary or Sequential Search?
			\part (Bonus) If you need to do a billion searches of your very large unsorted dataset, would it be better to do a billion Sequential Searches, or sort via MergeSort and then perform a billion Binary Searches?
		\end{parts}

	\question Write a program that reverses a String, \textit{str}, and prints the result to the console:
		\begin{parts}
			\part Using a loop.
			\part Using recursion.
		\end{parts}
    
   \pagebreak
    
	\question For each of the following, assume we have declared the following:
	\begin{lstlisting}
int[] arr = {1, 2, 3, 18};
int[] arr2 = new int[8];
int[][] arr3 = { {1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10} };
String s = "Hello World";
	\end{lstlisting}	
	Identify what the result will be, or write \textit{Compile-time} or \textit{Run-time} if there is a Compile-time or Run-time error:
		\begin{parts}
			\part arr[0];
			\part arr[arr2.length - 5];
			\part s.charAt(arr.length);
			\part s.charAt(arr[3]);
			\part s.charAt(arr[5]);
			\part s.charAt(arr[1]);
			\part arr3[arr.length];
			\part arr3[arr.length][1];
			\part arr3.length;
			\part arr3[0].length;
			\part arr3[1].length();
			\part s.length;
			\part s.charAt(s.indexOf('H'));
			\part s.charAt(s.indexOf('Q'));
			\part s.indexOf('Q');
			\part arr2[0];
			\part arr2 = arr;
			\part arr[0] = arr3[2][0] + arr3[3][0];
			\part arr[0] = (int) s.charAt(6);
			\part arr[0] = s.charAt(6);
			\part int j = 6.0;
			\part double d = 7;
			\part s += 'q';
			\part (s + "Goodbye!").length();
			\part s == ("Hello " + "World");
			\part s.equals("Hello " + "World");
		\end{parts}
    
	\pagebreak    
    
	\question In Milestone 2, we asked you to write a Player class which had the following methods: \\
		\begin{lstlisting}
			public void deal(Card c);
			public Card[] discard();
			public double wager(double min);
			public Hand showHand();
			public Hand showHand();
			public double getBalance();
			public void winnings(double amount);
		\end{lstlisting}
		
		Imagine a Poker game in which we have an array of players. Write a method that finds the total amount of money among all of the Players, and then computes the average amount of money held by a Player $$\text{(Hint): average} = \sum^N_i{\frac{\text{Player $i$'s balance}}{N}}$$
		\begin{lstlisting}
public static double findAverageBalance(Players[] players){
			
			
			
			
			
			
			
			
			
			
}
		\end{lstlisting}

		Now, let's assume that for a given Player, their minimum bet to be able to play is defined as:
		\[ \begin{cases} 
      		$player's balance * 10\%,$ & $player's balance $<$ average table balance$\\
      		$player's balance * 20\%,$ & $player's balance $\geq$ average table balance$\\
	   \end{cases}
		\]
		Write a method to compute this minimum within the Player class:
		\begin{lstlisting}
public double getMinimumBalance(double averageTableBalance){
			
			
			
			
			
			
			
			
			
			
}
		\end{lstlisting}
    
    \pagebreak

	\question Here is an implementation of fibonacci:
	\begin{lstlisting}
public int fibonacci(int n){
	if(n == 0) return 1;
	if(n == 1) return 1;
	return fibonacci(n - 1) + fibonacci(n - 2);
}
		\end{lstlisting}
		
		\begin{parts}
			\part The running time of this algorithm is $O(2^n)$. Is that \textit{better} or \textit{worse} than an algorithm that runs in $O(n^2)$? Is $O(2^n)$ \textit{better} or \textit{worse} than an algorithm that runs in $O(n)$? How about one that runs in $O(log_2(n))$ time? Rank them, from \textit{fastest} to \textit{slowest}:
			
			\oneline			
			
			\part Write a program that computes fibonacci of a given $n$, but without recursion:
			\begin{lstlisting}
public int fibonacci(int n){
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
}
			\end{lstlisting}
			\part What's the running time of the algorithm you wrote?
		\end{parts}
	
	\question Find at least five \textbf{syntactical} errors in the following program:
	\begin{lstlisting}
int j = 2.0;
answer = 0;
for(i = j; i < 12 i ++)
	answer = answer + Math.pow{i, 2);
}
	\end{lstlisting}

	\question The following code snippet is meant to find the sum of all of the numbers between 1 and 100. Find three \textbf{logical} errors:
	\begin{lstlisting}
int sum = 0;
for(int i = -1; i > 100; i ++){
	sum -= i;
}
	\end{lstlisting}
	
	\pagebreak

	\question Trace a MergeSort of the following dataset, showing the number of comparisons in each pass:
	$$\{7, 12, 100, 18, 23, 8, 1, 3, 4, 0, 19, 6, 4, 1, 20, 12\}$$
 \\
 \\
 \\
 \\
 \\
 \\
 \\
 \\
 \\
 
 \question Trace an Insertion Sort of the following dataset, showing the number of comparisons in each pass:
 $$\{8, 1, 3, 4, 0, 19\}$$
 \\
 \\
 \\
 \\
 \\
 \\
 \\
 \\
 \\
 
 \question Trace a Binary Search of the following dataset, where we are attempting to find the number 8.
 $$\{1, 3, 5, 6, 12, 19, 20, 25, 28, 33\}$$

\end{questions}

\end{document}